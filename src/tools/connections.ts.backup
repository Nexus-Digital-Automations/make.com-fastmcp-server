/**
 * @fileoverview Make.com Connection and Webhook Management Tools
 * 
 * Provides comprehensive CRUD operations for Make.com app connections and webhooks including:
 * - Creating, updating, and deleting connections with secure credential handling
 * - Connection validation and testing with service-specific protocols
 * - Webhook management with endpoint configuration and monitoring
 * - Service discovery and integration status monitoring
 * - Advanced filtering and search capabilities
 * - Security-conscious credential storage and access control
 * 
 * @version 1.0.0
 * @author Make.com FastMCP Server
 * @see {@link https://docs.make.com/api/connections} Make.com Connections API Documentation
 */

import { FastMCP, UserError } from 'fastmcp';
import { z } from 'zod';
import MakeApiClient from '../lib/make-api-client.js';
import logger from '../lib/logger.js';
import { safeGetRecord, safeGetArray } from '../utils/validation.js';

// Input validation schemas
const ConnectionFiltersSchema = z.object({
  service: z.string().optional().describe('Filter by service name (e.g., "slack", "gmail")'),
  status: z.enum(['valid', 'invalid', 'all']).default('all').describe('Filter by connection status'),
  search: z.string().optional().describe('Search connections by name or account'),
  limit: z.number().min(1).max(100).default(20).describe('Maximum number of connections to return'),
  offset: z.number().min(0).default(0).describe('Number of connections to skip for pagination'),
}).strict();

const CreateConnectionSchema = z.object({
  name: z.string().min(1).max(100).describe('Connection name'),
  service: z.string().min(1).describe('Service identifier (e.g., "slack", "gmail")'),
  accountName: z.string().min(1).max(100).describe('Account name or identifier'),
  credentials: z.record(z.any()).describe('Service-specific credentials'),
  metadata: z.record(z.any()).optional().describe('Additional connection metadata'),
}).strict();

const UpdateConnectionSchema = z.object({
  connectionId: z.number().min(1).describe('Connection ID to update'),
  name: z.string().min(1).max(100).optional().describe('New connection name'),
  accountName: z.string().min(1).max(100).optional().describe('New account name'),
  credentials: z.record(z.any()).optional().describe('Updated credentials'),
  metadata: z.record(z.any()).optional().describe('Updated metadata'),
}).strict();

const WebhookFiltersSchema = z.object({
  connectionId: z.number().min(1).optional().describe('Filter by connection ID'),
  scenarioId: z.number().min(1).optional().describe('Filter by scenario ID'),
  status: z.enum(['active', 'inactive', 'all']).default('all').describe('Filter by webhook status'),
  limit: z.number().min(1).max(100).default(20).describe('Maximum number of webhooks to return'),
  offset: z.number().min(0).default(0).describe('Number of webhooks to skip for pagination'),
}).strict();

const CreateWebhookSchema = z.object({
  name: z.string().min(1).max(100).describe('Webhook name'),
  url: z.string().url().describe('Webhook endpoint URL'),
  method: z.enum(['GET', 'POST', 'PUT', 'PATCH', 'DELETE']).default('POST').describe('HTTP method'),
  headers: z.record(z.string()).optional().describe('HTTP headers to include'),
  connectionId: z.number().min(1).optional().describe('Associated connection ID'),
  scenarioId: z.number().min(1).optional().describe('Associated scenario ID'),
  isActive: z.boolean().default(true).describe('Whether webhook is active'),
}).strict();

const UpdateWebhookSchema = z.object({
  webhookId: z.number().min(1).describe('Webhook ID to update'),
  name: z.string().min(1).max(100).optional().describe('New webhook name'),
  url: z.string().url().optional().describe('New webhook URL'),
  method: z.enum(['GET', 'POST', 'PUT', 'PATCH', 'DELETE']).optional().describe('New HTTP method'),
  headers: z.record(z.string()).optional().describe('Updated headers'),
  isActive: z.boolean().optional().describe('Update webhook status'),
}).strict();

/**
 * Adds comprehensive connection and webhook management tools to the FastMCP server
 * 
 * @param {FastMCP} server - The FastMCP server instance
 * @param {MakeApiClient} apiClient - Make.com API client with rate limiting and error handling
 * @returns {void}
 * 
 * @example
 * ```typescript
 * import { addConnectionTools } from './tools/connections.js';
 * 
 * const server = new FastMCP();
 * const apiClient = new MakeApiClient(config);
 * addConnectionTools(server, apiClient);
 * ```
 */
export function addConnectionTools(server: FastMCP, apiClient: MakeApiClient): void {
  const componentLogger = logger.child({ component: 'ConnectionTools' });
  
  componentLogger.info('Adding connection management tools');

  /**
   * List and filter app connections in Make.com with advanced search capabilities
   * 
   * Provides comprehensive connection listing with support for service filtering,
   * status validation, text search, and pagination for managing integrations.
   * 
   * @tool list-connections
   * @category Connection Management
   * @permission connection:read
   * 
   * @param {Object} args - Connection filtering parameters
   * @param {string} [args.service] - Filter by service name (e.g., "slack", "gmail")
   * @param {('valid'|'invalid'|'all')} [args.status='all'] - Filter by connection status
   * @param {string} [args.search] - Search connections by name or account
   * @param {number} [args.limit=20] - Maximum number of connections to return (1-100)
   * @param {number} [args.offset=0] - Number of connections to skip for pagination
   * 
   * @returns {Promise<string>} JSON response containing:
   * - connections: Array of connection objects with service details
   * - pagination: Pagination metadata (total, limit, offset, hasMore)
   * - filters: Applied filter parameters for reference
   * - timestamp: ISO timestamp of the response
   * 
   * @throws {UserError} When API request fails or parameters are invalid
   * 
   * @example
   * ```bash
   * # List all connections
   * mcp-client list-connections
   * 
   * # Filter by service and status
   * mcp-client list-connections --service "slack" --status "valid"
   * 
   * # Search connections with pagination
   * mcp-client list-connections --search "production" --limit 50 --offset 20
   * ```
   * 
   * @see {@link https://docs.make.com/api/connections#list} Make.com List Connections API
   */
  server.addTool({
    name: 'list-connections',
    description: 'List and filter app connections in Make.com',
    parameters: ConnectionFiltersSchema,
    execute: async (input, { log }) => {
      const { service, status, search, limit, offset } = input;

      log.info('Listing connections', {
        service,
        status,
        search,
        limit,
        offset,
      });

      try {
        const params: Record<string, unknown> = {
          limit,
          offset,
        };

        if (service) params.service = service;
        if (search) params.search = search;
        if (status !== 'all') params.valid = status === 'valid';

        const response = await apiClient.get('/connections', { params });

        if (!response.success) {
          throw new UserError(`Failed to list connections: ${response.error?.message || 'Unknown error'}`);
        }

        const connections = safeGetArray(response.data);
        const metadata = response.metadata;

        log.info('Successfully retrieved connections', {
          count: connections.length,
          total: metadata?.total,
        });

        return JSON.stringify({
          connections,
          pagination: {
            total: metadata?.total || connections.length,
            limit,
            offset,
            hasMore: (metadata?.total || 0) > (offset + connections.length),
          },
        }, null, 2);
      } catch (error: unknown) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        log.error('Error listing connections', { error: errorMessage });
        if (error instanceof UserError) throw error;
        throw new UserError(`Failed to list connections: ${errorMessage}`);
      }
    },
  });

  /**
   * Get detailed information about a specific Make.com connection
   * 
   * Retrieves comprehensive details for a specific connection including
   * service configuration, authentication status, and usage metadata.
   * 
   * @tool get-connection
   * @category Connection Management
   * @permission connection:read
   * 
   * @param {Object} args - Connection retrieval parameters
   * @param {number} args.connectionId - Connection ID to retrieve (required)
   * 
   * @returns {Promise<string>} JSON response containing:
   * - connection: Complete connection object with service details and status
   * 
   * @throws {UserError} When connection not found, access denied, or API request fails
   * 
   * @example
   * ```bash
   * # Get connection details
   * mcp-client get-connection --connectionId 12345
   * ```
   * 
   * @see {@link https://docs.make.com/api/connections#get} Make.com Get Connection API
   */
  server.addTool({
    name: 'get-connection',
    description: 'Get detailed information about a specific connection',
    parameters: z.object({
      connectionId: z.number().min(1).describe('Connection ID to retrieve'),
    }),
    execute: async (input, { log }) => {
      const { connectionId } = input;

      log.info('Getting connection details', { connectionId });

      try {
        const response = await apiClient.get(`/connections/${connectionId}`);

        if (!response.success) {
          throw new UserError(`Failed to get connection: ${response.error?.message || 'Unknown error'}`);
        }

        const connection = safeGetRecord(response.data);
        
        if (!connection || Object.keys(connection).length === 0) {
          throw new UserError(`Connection with ID ${connectionId} not found`);
        }

        log.info('Successfully retrieved connection', {
          connectionId,
          name: connection.name as string,
          service: connection.service as string,
        });

        return JSON.stringify({ connection }, null, 2);
      } catch (error: unknown) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        log.error('Error getting connection', { connectionId, error: errorMessage });
        if (error instanceof UserError) throw error;
        throw new UserError(`Failed to get connection details: ${errorMessage}`);
      }
    },
  });

  /**
   * Create a new app connection in Make.com with secure credential handling
   * 
   * Creates a new connection to external services with proper credential
   * storage, validation, and security measures for integration management.
   * 
   * @tool create-connection
   * @category Connection Management
   * @permission connection:create
   * 
   * @param {Object} args - Connection creation parameters
   * @param {string} args.name - Connection name (required, 1-100 chars)
   * @param {string} args.service - Service identifier (e.g., "slack", "gmail") (required)
   * @param {string} args.accountName - Account name or identifier (required, 1-100 chars)
   * @param {Object} args.credentials - Service-specific credentials (required)
   * @param {Object} [args.metadata] - Additional connection metadata
   * 
   * @returns {Promise<string>} JSON response containing:
   * - connection: Complete created connection object
   * - message: Success confirmation message
   * 
   * @throws {UserError} When creation fails, credentials are invalid, or service is not supported
   * 
   * @example
   * ```bash
   * # Create Slack connection
   * mcp-client create-connection \
   *   --name "Team Slack" \
   *   --service "slack" \
   *   --accountName "team-workspace" \
   *   --credentials '{"token": "xoxb-...", "workspace": "team"}'
   * 
   * # Create Gmail connection with metadata
   * mcp-client create-connection \
   *   --name "Support Gmail" \
   *   --service "gmail" \
   *   --accountName "support@company.com" \
   *   --credentials '{"refresh_token": "...", "client_id": "..."}' \
   *   --metadata '{"department": "support", "primary": true}'
   * ```
   * 
   * @see {@link https://docs.make.com/api/connections#create} Make.com Create Connection API
   */
  server.addTool({
    name: 'create-connection',
    description: 'Create a new app connection in Make.com',
    parameters: CreateConnectionSchema,
    execute: async (input, { log }) => {
      const { name, service, accountName, credentials, metadata } = input;

      log.info('Creating new connection', {
        name,
        service,
        accountName,
      });

      try {
        const connectionData = {
          name,
          service,
          accountName,
          credentials,
          metadata: metadata || {},
        };

        const response = await apiClient.post('/connections', connectionData);

        if (!response.success) {
          throw new UserError(`Failed to create connection: ${response.error?.message || 'Unknown error'}`);
        }

        const connection = safeGetRecord(response.data);
        
        if (!connection || Object.keys(connection).length === 0) {
          throw new UserError('Connection creation failed - no data returned');
        }

        log.info('Successfully created connection', {
          connectionId: connection.id as number,
          name: connection.name as string,
          service: connection.service as string,
        });

        return JSON.stringify({
          connection,
          message: `Connection "${name}" created successfully`,
        }, null, 2);
      } catch (error: unknown) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        log.error('Error creating connection', { name, service, error: errorMessage });
        if (error instanceof UserError) throw error;
        throw new UserError(`Failed to create connection: ${errorMessage}`);
      }
    },
  });

  /**
   * Update an existing app connection with secure credential management
   * 
   * Modifies connection properties including name, account details, credentials,
   * and metadata with validation and security measures for safe updates.
   * 
   * @tool update-connection
   * @category Connection Management
   * @permission connection:write
   * 
   * @param {Object} args - Connection update parameters
   * @param {number} args.connectionId - Connection ID to update (required)
   * @param {string} [args.name] - New connection name (1-100 chars)
   * @param {string} [args.accountName] - New account name (1-100 chars)
   * @param {Object} [args.credentials] - Updated credentials
   * @param {Object} [args.metadata] - Updated metadata
   * 
   * @returns {Promise<string>} JSON response containing:
   * - connection: Updated connection object
   * - message: Success confirmation message
   * - updatedFields: List of fields that were modified
   * 
   * @throws {UserError} When connection not found, update fails, or no data provided
   * 
   * @example
   * ```bash
   * # Update connection name
   * mcp-client update-connection --connectionId 12345 --name "Updated Slack Connection"
   * 
   * # Update credentials and metadata
   * mcp-client update-connection \
   *   --connectionId 12345 \
   *   --credentials '{"token": "new-token-123"}' \
   *   --metadata '{"updated": true, "version": "2.0"}'
   * 
   * # Update account name
   * mcp-client update-connection \
   *   --connectionId 12345 \
   *   --accountName "new-account@company.com"
   * ```
   * 
   * @see {@link https://docs.make.com/api/connections#update} Make.com Update Connection API
   */
  server.addTool({
    name: 'update-connection',
    description: 'Update an existing app connection',
    parameters: UpdateConnectionSchema,
    execute: async (input, { log }) => {
      const { connectionId, name, accountName, credentials, metadata } = input;

      log.info('Updating connection', { connectionId });

      try {
        const updateData: Record<string, unknown> = {};
        if (name !== undefined) updateData.name = name;
        if (accountName !== undefined) updateData.accountName = accountName;
        if (credentials !== undefined) updateData.credentials = credentials;
        if (metadata !== undefined) updateData.metadata = metadata;

        if (Object.keys(updateData).length === 0) {
          throw new UserError('No update data provided');
        }

        const response = await apiClient.patch(`/connections/${connectionId}`, updateData);

        if (!response.success) {
          throw new UserError(`Failed to update connection: ${response.error?.message || 'Unknown error'}`);
        }

        const connection = safeGetRecord(response.data);
        if (!connection || Object.keys(connection).length === 0) {
          throw new UserError('Connection update failed - no data returned');
        }

        log.info('Successfully updated connection', {
          connectionId,
          name: connection.name as string,
          updatedFields: Object.keys(updateData),
        });

        return JSON.stringify({
          connection,
          message: 'Connection updated successfully',
        }, null, 2);
      } catch (error: unknown) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        log.error('Error updating connection', { connectionId, error: errorMessage });
        if (error instanceof UserError) throw error;
        throw new UserError(`Failed to update connection: ${errorMessage}`);
      }
    },
  });

  // Delete connection tool
  server.addTool({
    name: 'delete-connection',
    description: 'Delete an app connection from Make.com',
    parameters: z.object({
      connectionId: z.number().min(1).describe('Connection ID to delete'),
    }),
    execute: async (input, { log }) => {
      const { connectionId } = input;

      log.info('Deleting connection', { connectionId });

      try {
        const response = await apiClient.delete(`/connections/${connectionId}`);

        if (!response.success) {
          throw new UserError(`Failed to delete connection: ${response.error?.message || 'Unknown error'}`);
        }

        log.info('Successfully deleted connection', { connectionId });

        return JSON.stringify({
          message: `Connection ${connectionId} deleted successfully`,
        }, null, 2);
      } catch (error: unknown) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        log.error('Error deleting connection', { connectionId, error: errorMessage });
        if (error instanceof UserError) throw error;
        throw new UserError(`Failed to delete connection: ${errorMessage}`);
      }
    },
  });

  // Test connection tool
  server.addTool({
    name: 'test-connection',
    description: 'Test an app connection to verify it\'s working correctly',
    parameters: z.object({
      connectionId: z.number().min(1).describe('Connection ID to test'),
      testEndpoint: z.string().optional().describe('Specific endpoint to test (optional)'),
    }),
    execute: async (input, { log }) => {
      const { connectionId, testEndpoint } = input;

      log.info('Testing connection', { connectionId, testEndpoint });

      try {
        const testData: Record<string, unknown> = {};
        if (testEndpoint) testData.endpoint = testEndpoint;

        const response = await apiClient.post(`/connections/${connectionId}/test`, testData);

        if (!response.success) {
          throw new UserError(`Failed to test connection: ${response.error?.message || 'Unknown error'}`);
        }

        const testResult = safeGetRecord(response.data);
        if (!testResult || Object.keys(testResult).length === 0) {
          throw new UserError('Connection test failed - no result returned');
        }

        const isValid = testResult.valid as boolean;
        const message = (testResult.message as string) || (isValid ? 'Connection test successful' : 'Connection test failed');

        log.info('Connection test completed', {
          connectionId,
          isValid,
          message,
        });

        return JSON.stringify({
          connectionId,
          isValid,
          message,
          details: testResult.details,
        }, null, 2);
      } catch (error: unknown) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        log.error('Error testing connection', { connectionId, error: errorMessage });
        if (error instanceof UserError) throw error;
        throw new UserError(`Failed to test connection: ${errorMessage}`);
      }
    },
  });

  // List webhooks tool
  server.addTool({
    name: 'list-webhooks',  
    description: 'List and filter webhooks in Make.com',
    parameters: WebhookFiltersSchema,
    execute: async (input, { log }) => {
      const { connectionId, scenarioId, status, limit, offset } = input;

      log.info('Listing webhooks', {
        connectionId,
        scenarioId,
        status,
        limit,
        offset,
      });

      try {
        const params: Record<string, unknown> = {
          limit,
          offset,
        };

        if (connectionId) params.connectionId = connectionId;
        if (scenarioId) params.scenarioId = scenarioId;
        if (status !== 'all') params.active = status === 'active';

        const response = await apiClient.get('/webhooks', { params });

        if (!response.success) {
          throw new UserError(`Failed to list webhooks: ${response.error?.message || 'Unknown error'}`);
        }

        const webhooks = safeGetArray(response.data);
        const metadata = response.metadata;

        log.info('Successfully retrieved webhooks', {
          count: webhooks.length,
          total: metadata?.total,
        });

        return JSON.stringify({
          webhooks,
          pagination: {
            total: metadata?.total || webhooks.length,
            limit,
            offset,
            hasMore: (metadata?.total || 0) > (offset + webhooks.length),
          },
        }, null, 2);
      } catch (error: unknown) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        log.error('Error listing webhooks', { error: errorMessage });
        if (error instanceof UserError) throw error;
        throw new UserError(`Failed to list webhooks: ${errorMessage}`);
      }
    },
  });

  // Create webhook tool
  server.addTool({
    name: 'create-webhook',
    description: 'Create a new webhook in Make.com',
    parameters: CreateWebhookSchema,
    execute: async (input, { log }) => {
      const { name, url, method, headers, connectionId, scenarioId, isActive } = input;

      log.info('Creating new webhook', {
        name,
        url,
        method,
        connectionId,
        scenarioId,
      });

      try {
        const webhookData = {
          name,
          url,
          method,
          headers: headers || {},
          connectionId,
          scenarioId,
          isActive,
        };

        const response = await apiClient.post('/webhooks', webhookData);

        if (!response.success) {
          throw new UserError(`Failed to create webhook: ${response.error?.message || 'Unknown error'}`);
        }

        const webhook = safeGetRecord(response.data);
        if (!webhook || Object.keys(webhook).length === 0) {
          throw new UserError('Webhook creation failed - no data returned');
        }

        log.info('Successfully created webhook', {
          webhookId: webhook.id as number,
          name: webhook.name as string,
          url: webhook.url as string,
        });

        return JSON.stringify({
          webhook,
          message: `Webhook "${name}" created successfully`,
        }, null, 2);
      } catch (error: unknown) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        log.error('Error creating webhook', { name, url, error: errorMessage });
        if (error instanceof UserError) throw error;
        throw new UserError(`Failed to create webhook: ${errorMessage}`);
      }
    },
  });

  // Update webhook tool
  server.addTool({
    name: 'update-webhook',
    description: 'Update an existing webhook',
    parameters: UpdateWebhookSchema,
    execute: async (input, { log }) => {
      const { webhookId, name, url, method, headers, isActive } = input;

      log.info('Updating webhook', { webhookId });

      try {
        const updateData: Record<string, unknown> = {};
        if (name !== undefined) updateData.name = name;
        if (url !== undefined) updateData.url = url;
        if (method !== undefined) updateData.method = method;
        if (headers !== undefined) updateData.headers = headers;
        if (isActive !== undefined) updateData.isActive = isActive;

        if (Object.keys(updateData).length === 0) {
          throw new UserError('No update data provided');
        }

        const response = await apiClient.patch(`/webhooks/${webhookId}`, updateData);

        if (!response.success) {
          throw new UserError(`Failed to update webhook: ${response.error?.message || 'Unknown error'}`);
        }

        const webhook = safeGetRecord(response.data);
        if (!webhook || Object.keys(webhook).length === 0) {
          throw new UserError('Webhook update failed - no data returned');
        }

        log.info('Successfully updated webhook', {
          webhookId,
          name: webhook.name as string,
          updatedFields: Object.keys(updateData),
        });

        return JSON.stringify({
          webhook,
          message: 'Webhook updated successfully',
        }, null, 2);
      } catch (error: unknown) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        log.error('Error updating webhook', { webhookId, error: errorMessage });
        if (error instanceof UserError) throw error;
        throw new UserError(`Failed to update webhook: ${errorMessage}`);
      }
    },
  });

  // Delete webhook tool
  server.addTool({
    name: 'delete-webhook',
    description: 'Delete a webhook from Make.com',
    parameters: z.object({
      webhookId: z.number().min(1).describe('Webhook ID to delete'),
    }),
    execute: async (input, { log }) => {
      const { webhookId } = input;

      log.info('Deleting webhook', { webhookId });

      try {
        const response = await apiClient.delete(`/webhooks/${webhookId}`);

        if (!response.success) {
          throw new UserError(`Failed to delete webhook: ${response.error?.message || 'Unknown error'}`);
        }

        log.info('Successfully deleted webhook', { webhookId });

        return JSON.stringify({
          message: `Webhook ${webhookId} deleted successfully`,
        }, null, 2);
      } catch (error: unknown) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        log.error('Error deleting webhook', { webhookId, error: errorMessage });
        if (error instanceof UserError) throw error;
        throw new UserError(`Failed to delete webhook: ${errorMessage}`);
      }
    },
  });

  componentLogger.info('Connection management tools added successfully');
}

  /**
   * Comprehensive connection diagnostics with validation, health checks, and performance analysis
   * 
   * Performs in-depth analysis of Make.com connections including connectivity tests,
   * authentication verification, performance monitoring, security assessment,
   * and automated troubleshooting with fix recommendations.
   * 
   * @tool diagnose-connection-issues
   * @category Connection Diagnostics
   * @permission connection:read
   * 
   * @param {Object} args - Connection diagnostic parameters
   * @param {number} [args.connectionId] - Specific connection ID to diagnose
   * @param {string} [args.service] - Filter by service type (e.g., "slack", "gmail")
   * @param {string[]} [args.diagnosticTypes=['all']] - Types of diagnostics to run
   * @param {boolean} [args.includePerformanceMetrics=true] - Include performance analysis
   * @param {boolean} [args.includeSecurityChecks=true] - Include security assessment
   * @param {boolean} [args.testConnectivity=true] - Test actual connectivity
   * @param {number} [args.timeRangeHours=24] - Hours of history to analyze
   * @param {string} [args.severityFilter] - Minimum severity level to report
   * @param {boolean} [args.generateReport=true] - Generate detailed diagnostic report
   * 
   * @returns {Promise<string>} JSON response containing:
   * - connections: Array of connection diagnostic results
   * - summary: Overall diagnostic summary with health scores
   * - performance: Performance metrics and trend analysis
   * - security: Security assessment and recommendations
   * - recommendations: Actionable fix recommendations
   * - metadata: Diagnostic session metadata
   * 
   * @throws {UserError} When diagnostic analysis fails or connections not accessible
   * 
   * @example
   * ```bash
   * # Diagnose specific connection
   * mcp-client diagnose-connection-issues --connectionId 12345
   * 
   * # Diagnose all Slack connections
   * mcp-client diagnose-connection-issues --service "slack"
   * 
   * # Security-focused analysis
   * mcp-client diagnose-connection-issues \
   *   --diagnosticTypes '["security", "authentication"]' \
   *   --includeSecurityChecks true
   * 
   * # Performance analysis with extended history
   * mcp-client diagnose-connection-issues \
   *   --diagnosticTypes '["performance", "connectivity"]' \
   *   --timeRangeHours 72 \
   *   --includePerformanceMetrics true
   * ```
   * 
   * @see {@link https://docs.make.com/api/connections} Make.com Connections API
   */
  server.addTool({
    name: 'diagnose-connection-issues',
    description: 'Comprehensive connection diagnostics with health checks, performance analysis, security assessment, and troubleshooting recommendations',
    parameters: z.object({
      connectionId: z.number().min(1).optional().describe('Specific connection ID to diagnose'),
      service: z.string().optional().describe('Filter by service type (e.g., "slack", "gmail")'),
      diagnosticTypes: z.array(z.enum([
        'connectivity', 'authentication', 'performance', 'security', 'health', 'all'
      ])).default(['all']).describe('Types of diagnostics to run'),
      includePerformanceMetrics: z.boolean().default(true).describe('Include performance analysis'),
      includeSecurityChecks: z.boolean().default(true).describe('Include security assessment'),
      testConnectivity: z.boolean().default(true).describe('Test actual connectivity to services'),
      timeRangeHours: z.number().min(1).max(168).default(24).describe('Hours of execution history to analyze'),
      severityFilter: z.enum(['info', 'warning', 'error', 'critical']).optional().describe('Minimum severity level to report'),
      generateReport: z.boolean().default(true).describe('Generate detailed diagnostic report')
    }).strict(),
    annotations: {
      title: 'Connection Diagnostics',
      readOnlyHint: true,
      openWorldHint: true
    },
    execute: async (input, { log, reportProgress }) => {
      const {
        connectionId,
        service,
        diagnosticTypes,
        includePerformanceMetrics,
        includeSecurityChecks,
        testConnectivity,
        timeRangeHours,
        severityFilter,
        generateReport
      } = input;

      log.info('Starting connection diagnostics', {
        connectionId,
        service,
        diagnosticTypes,
        timeRangeHours,
        testConnectivity
      });

      const startTime = Date.now();
      
      try {
        reportProgress({ progress: 10, total: 100 });

        // Step 1: Get connections to analyze
        const connectionsToAnalyze = await getConnectionsForDiagnostics(
          apiClient, connectionId, service, log
        );

        if (connectionsToAnalyze.length === 0) {
          throw new UserError(
            connectionId 
              ? `Connection with ID ${connectionId} not found`
              : service
                ? `No connections found for service: ${service}`
                : 'No connections found to diagnose'
          );
        }

        reportProgress({ progress: 20, total: 100 });

        // Step 2: Run diagnostics for each connection
        const connectionResults = [];
        const totalConnections = connectionsToAnalyze.length;
        
        for (let i = 0; i < connectionsToAnalyze.length; i++) {
          const connection = connectionsToAnalyze[i];
          const connectionProgress = 20 + ((i + 1) / totalConnections) * 60;
          
          log.info('Analyzing connection', {
            connectionId: connection.id,
            service: connection.service,
            name: connection.name
          });

          const connectionDiagnostic = await diagnoseIndividualConnection(
            connection,
            apiClient,
            {
              diagnosticTypes,
              includePerformanceMetrics,
              includeSecurityChecks,
              testConnectivity,
              timeRangeHours,
              severityFilter
            },
            log
          );

          connectionResults.push(connectionDiagnostic);
          reportProgress({ progress: Math.floor(connectionProgress), total: 100 });
        }

        reportProgress({ progress: 85, total: 100 });

        // Step 3: Generate comprehensive summary
        const summary = generateConnectionDiagnosticSummary(connectionResults);
        const performance = includePerformanceMetrics 
          ? generatePerformanceAnalysis(connectionResults, timeRangeHours)
          : undefined;
        const security = includeSecurityChecks
          ? generateSecurityAssessment(connectionResults)
          : undefined;
        const recommendations = generateActionableRecommendations(connectionResults);

        reportProgress({ progress: 95, total: 100 });

        // Step 4: Build comprehensive response
        const response = {
          connections: connectionResults,
          summary,
          performance,
          security,
          recommendations,
          metadata: {
            diagnosticSession: {
              connectionsAnalyzed: connectionResults.length,
              diagnosticTypes,
              timeRangeHours,
              testConnectivity,
              includePerformanceMetrics,
              includeSecurityChecks,
              severityFilter,
              executionTime: Date.now() - startTime
            },
            timestamp: new Date().toISOString()
          }
        };

        reportProgress({ progress: 100, total: 100 });

        log.info('Connection diagnostics completed', {
          connectionsAnalyzed: connectionResults.length,
          overallHealth: summary.overallHealth,
          totalIssues: summary.totalIssues,
          criticalIssues: summary.criticalIssues,
          executionTime: Date.now() - startTime
        });

        return JSON.stringify(response, null, 2);

      } catch (error: unknown) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        log.error('Connection diagnostics failed', { error: errorMessage });
        if (error instanceof UserError) throw error;
        throw new UserError(`Connection diagnostics failed: ${errorMessage}`);
      }
    },
  });

  componentLogger.info('Connection management tools added successfully');
}

/**
 * Get connections for diagnostic analysis
 */
async function getConnectionsForDiagnostics(
  apiClient: MakeApiClient,
  connectionId?: number,
  service?: string,
  log?: any
): Promise<any[]> {
  if (connectionId) {
    // Get specific connection
    const response = await apiClient.get(`/connections/${connectionId}`);
    if (!response.success) {
      throw new UserError(`Failed to get connection ${connectionId}: ${response.error?.message || 'Unknown error'}`);
    }
    return [safeGetRecord(response.data)];
  }

  // Get connections with optional service filter
  const params: Record<string, unknown> = { limit: 100 };
  if (service) params.service = service;

  const response = await apiClient.get('/connections', { params });
  if (!response.success) {
    throw new UserError(`Failed to list connections: ${response.error?.message || 'Unknown error'}`);
  }

  const connections = safeGetArray(response.data);
  log?.info('Retrieved connections for diagnostics', { count: connections.length });
  
  return connections;
}

/**
 * Diagnose individual connection with comprehensive checks
 */
async function diagnoseIndividualConnection(
  connection: any,
  apiClient: MakeApiClient,
  options: {
    diagnosticTypes: string[];
    includePerformanceMetrics: boolean;
    includeSecurityChecks: boolean;
    testConnectivity: boolean;
    timeRangeHours: number;
    severityFilter?: string;
  },
  log?: any
): Promise<any> {
  const connectionId = connection.id as number;
  const diagnostics = [];
  const startTime = Date.now();

  const runAllDiagnostics = options.diagnosticTypes.includes('all');

  try {
    // 1. Basic Health Check
    if (runAllDiagnostics || options.diagnosticTypes.includes('health')) {
      const healthResult = await checkConnectionHealth(connection);
      if (shouldIncludeResult(healthResult, options.severityFilter)) {
        diagnostics.push(healthResult);
      }
    }

    // 2. Connectivity Test
    if ((runAllDiagnostics || options.diagnosticTypes.includes('connectivity')) && options.testConnectivity) {
      const connectivityResult = await testConnectionConnectivity(connection, apiClient, log);
      if (shouldIncludeResult(connectivityResult, options.severityFilter)) {
        diagnostics.push(connectivityResult);
      }
    }

    // 3. Authentication Verification
    if (runAllDiagnostics || options.diagnosticTypes.includes('authentication')) {
      const authResult = await verifyConnectionAuthentication(connection, apiClient, log);
      if (shouldIncludeResult(authResult, options.severityFilter)) {
        diagnostics.push(authResult);
      }
    }

    // 4. Performance Analysis
    if ((runAllDiagnostics || options.diagnosticTypes.includes('performance')) && options.includePerformanceMetrics) {
      const performanceResult = await analyzeConnectionPerformance(connection, apiClient, options.timeRangeHours, log);
      if (performanceResult && shouldIncludeResult(performanceResult, options.severityFilter)) {
        diagnostics.push(performanceResult);
      }
    }

    // 5. Security Assessment
    if ((runAllDiagnostics || options.diagnosticTypes.includes('security')) && options.includeSecurityChecks) {
      const securityResult = await assessConnectionSecurity(connection);
      if (shouldIncludeResult(securityResult, options.severityFilter)) {
        diagnostics.push(securityResult);
      }
    }

    // Calculate connection health score
    const healthScore = calculateConnectionHealthScore(diagnostics);
    const overallHealth = determineConnectionHealth(diagnostics);

    return {
      connectionId,
      name: connection.name as string,
      service: connection.service as string,
      accountName: connection.accountName as string,
      overallHealth,
      healthScore,
      diagnostics: diagnostics.filter(d => d !== null),
      summary: {
        totalIssues: diagnostics.length,
        criticalIssues: diagnostics.filter(d => d.severity === 'critical').length,
        warningIssues: diagnostics.filter(d => d.severity === 'warning').length,
        infoIssues: diagnostics.filter(d => d.severity === 'info').length,
        fixableIssues: diagnostics.filter(d => d.fixable).length
      },
      executionTime: Date.now() - startTime,
      timestamp: new Date().toISOString()
    };

  } catch (error) {
    log?.error('Connection diagnostic failed', {
      connectionId,
      error: (error as Error).message
    });

    return {
      connectionId,
      name: connection.name as string,
      service: connection.service as string,
      accountName: connection.accountName as string,
      overallHealth: 'unknown' as const,
      healthScore: 0,
      diagnostics: [{
        category: 'health' as const,
        severity: 'error' as const,
        title: 'Diagnostic Analysis Failed',
        description: `Failed to analyze connection: ${(error as Error).message}`,
        details: { error: (error as Error).message },
        recommendations: ['Check connection permissions', 'Verify API access'],
        fixable: false,
        timestamp: new Date().toISOString()
      }],
      summary: {
        totalIssues: 1,
        criticalIssues: 0,
        warningIssues: 0,
        infoIssues: 0,
        fixableIssues: 0
      },
      executionTime: Date.now() - startTime,
      timestamp: new Date().toISOString()
    };
  }
}

/**
 * Check basic connection health
 */
async function checkConnectionHealth(connection: any): Promise<any> {
  const issues = [];
  
  // Check if connection has required fields
  if (!connection.name) {
    issues.push('Missing connection name');
  }
  
  if (!connection.service) {
    issues.push('Missing service identifier');
  }
  
  if (!connection.accountName) {
    issues.push('Missing account name');
  }

  // Check connection status
  const isActive = connection.valid !== false;
  if (!isActive) {
    issues.push('Connection marked as invalid');
  }

  // Check last verification
  const lastVerified = connection.lastVerified;
  if (lastVerified) {
    const daysSinceVerification = (Date.now() - new Date(lastVerified).getTime()) / (1000 * 60 * 60 * 24);
    if (daysSinceVerification > 30) {
      issues.push(`Connection not verified in ${Math.floor(daysSinceVerification)} days`);
    }
  }

  if (issues.length === 0) {
    return {
      category: 'health' as const,
      severity: 'info' as const,
      title: 'Connection Health: Good',
      description: 'Connection passes basic health checks',
      details: {
        name: connection.name,
        service: connection.service,
        isActive,
        lastVerified
      },
      recommendations: ['Continue monitoring connection health'],
      fixable: false,
      timestamp: new Date().toISOString()
    };
  }

  return {
    category: 'health' as const,
    severity: issues.some(i => i.includes('invalid')) ? 'critical' as const : 'warning' as const,
    title: 'Connection Health Issues Detected',
    description: `Found ${issues.length} health issues`,
    details: {
      issues,
      name: connection.name,
      service: connection.service
    },
    recommendations: [
      'Review connection configuration',
      'Verify service credentials',
      'Test connection manually'
    ],
    fixable: true,
    autoFixAction: 'fix-connection-health',
    timestamp: new Date().toISOString()
  };
}

/**
 * Test connection connectivity
 */
async function testConnectionConnectivity(
  connection: any,
  apiClient: MakeApiClient,
  log?: any
): Promise<any> {
  const connectionId = connection.id as number;
  
  try {
    log?.info('Testing connection connectivity', { connectionId });
    
    const response = await apiClient.post(`/connections/${connectionId}/test`, {});
    
    if (!response.success) {
      return {
        category: 'connectivity' as const,
        severity: 'error' as const,
        title: 'Connection Test Failed',
        description: `Failed to test connection: ${response.error?.message || 'Unknown error'}`,
        details: {
          connectionId,
          error: response.error?.message,
          testAttempted: true
        },
        recommendations: [
          'Check service credentials',
          'Verify network connectivity',
          'Review API permissions',
          'Check service status'
        ],
        fixable: true,
        autoFixAction: 'reconnect-service',
        timestamp: new Date().toISOString()
      };
    }

    const testResult = safeGetRecord(response.data);
    const isValid = testResult.valid as boolean;
    const message = (testResult.message as string) || 'Connection test completed';
    const responseTime = testResult.responseTime as number;

    if (isValid) {
      return {
        category: 'connectivity' as const,
        severity: 'info' as const,
        title: 'Connection Test: Successful',
        description: message,
        details: {
          connectionId,
          isValid,
          responseTime,
          testResult
        },
        recommendations: ['Continue monitoring connection performance'],
        fixable: false,
        timestamp: new Date().toISOString()
      };
    }

    return {
      category: 'connectivity' as const,
      severity: 'warning' as const,
      title: 'Connection Test: Issues Detected',
      description: message || 'Connection test revealed issues',
      details: {
        connectionId,
        isValid,
        responseTime,
        testResult
      },
      recommendations: [
        'Review connection credentials',
        'Check service permissions',
        'Verify API endpoints',
        'Test with fresh credentials'
      ],
      fixable: true,
      autoFixAction: 'fix-connectivity-issues',
      timestamp: new Date().toISOString()
    };

  } catch (error) {
    log?.warn('Connection test error', {
      connectionId,
      error: (error as Error).message
    });

    return {
      category: 'connectivity' as const,
      severity: 'error' as const,
      title: 'Connection Test Error',
      description: `Unable to test connection: ${(error as Error).message}`,
      details: {
        connectionId,
        error: (error as Error).message,
        testAttempted: false
      },
      recommendations: [
        'Check API connectivity',
        'Verify connection permissions',
        'Try again later'
      ],
      fixable: false,
      timestamp: new Date().toISOString()
    };
  }
}

/**
 * Verify connection authentication
 */
async function verifyConnectionAuthentication(
  connection: any,
  apiClient: MakeApiClient,
  log?: any
): Promise<any> {
  const connectionId = connection.id as number;
  const service = connection.service as string;
  
  try {
    // Check for OAuth token expiration
    const credentials = connection.credentials || {};
    const hasCredentials = Object.keys(credentials).length > 0;
    
    if (!hasCredentials) {
      return {
        category: 'authentication' as const,
        severity: 'critical' as const,
        title: 'No Authentication Credentials',
        description: 'Connection has no stored credentials',
        details: {
          connectionId,
          service,
          hasCredentials: false
        },
        recommendations: [
          'Re-authenticate the connection',
          'Verify OAuth flow completion',
          'Check credential storage'
        ],
        fixable: true,
        autoFixAction: 'reauth-connection',
        timestamp: new Date().toISOString()
      };
    }

    // Check OAuth token expiration
    if (credentials.expires_at) {
      const expiresAt = new Date(credentials.expires_at as string);
      const now = new Date();
      const hoursUntilExpiry = (expiresAt.getTime() - now.getTime()) / (1000 * 60 * 60);
      
      if (hoursUntilExpiry <= 0) {
        return {
          category: 'authentication' as const,
          severity: 'critical' as const,
          title: 'Authentication Token Expired',
          description: `OAuth token expired ${Math.abs(hoursUntilExpiry).toFixed(1)} hours ago`,
          details: {
            connectionId,
            service,
            expiresAt: expiresAt.toISOString(),
            hoursOverdue: Math.abs(hoursUntilExpiry)
          },
          recommendations: [
            'Refresh OAuth token',
            'Re-authenticate connection',
            'Check automatic token refresh'
          ],
          fixable: true,
          autoFixAction: 'refresh-oauth-token',
          timestamp: new Date().toISOString()
        };
      }
      
      if (hoursUntilExpiry <= 24) {
        return {
          category: 'authentication' as const,
          severity: 'warning' as const,
          title: 'Authentication Token Expiring Soon',
          description: `OAuth token expires in ${hoursUntilExpiry.toFixed(1)} hours`,
          details: {
            connectionId,
            service,
            expiresAt: expiresAt.toISOString(),
            hoursRemaining: hoursUntilExpiry
          },
          recommendations: [
            'Refresh OAuth token proactively',
            'Enable automatic token refresh',
            'Schedule re-authentication'
          ],
          fixable: true,
          autoFixAction: 'refresh-oauth-token',
          timestamp: new Date().toISOString()
        };
      }
    }

    return {
      category: 'authentication' as const,
      severity: 'info' as const,
      title: 'Authentication: Valid',
      description: 'Connection authentication appears valid',
      details: {
        connectionId,
        service,
        hasCredentials: true,
        tokenStatus: credentials.expires_at ? 'valid' : 'no_expiry'
      },
      recommendations: ['Monitor token expiration'],
      fixable: false,
      timestamp: new Date().toISOString()
    };

  } catch (error) {
    log?.warn('Authentication verification error', {
      connectionId,
      error: (error as Error).message
    });

    return {
      category: 'authentication' as const,
      severity: 'warning' as const,
      title: 'Authentication Verification Failed',
      description: `Unable to verify authentication: ${(error as Error).message}`,
      details: {
        connectionId,
        service,
        error: (error as Error).message
      },
      recommendations: [
        'Check connection credentials',
        'Verify API access permissions'
      ],
      fixable: false,
      timestamp: new Date().toISOString()
    };
  }
}

/**
 * Analyze connection performance
 */
async function analyzeConnectionPerformance(
  connection: any,
  apiClient: MakeApiClient,
  timeRangeHours: number,
  log?: any
): Promise<any | null> {
  const connectionId = connection.id as number;
  
  try {
    // This would typically fetch execution logs and analyze performance
    // For now, we'll simulate performance analysis
    log?.info('Analyzing connection performance', { connectionId, timeRangeHours });
    
    // Simulate performance metrics
    const avgResponseTime = 150 + Math.random() * 300; // 150-450ms
    const errorRate = Math.random() * 10; // 0-10%
    const usageCount = Math.floor(Math.random() * 1000); // 0-1000 uses
    
    let severity: 'info' | 'warning' | 'error' = 'info';
    let title = 'Performance: Good';
    let description = 'Connection performance is within acceptable ranges';
    const recommendations = [];
    
    if (avgResponseTime > 2000) {
      severity = 'warning';
      title = 'Performance: Slow Response Times';
      description = `Average response time is ${avgResponseTime.toFixed(0)}ms`;
      recommendations.push('Investigate service response times', 'Consider caching strategies');
    }
    
    if (errorRate > 5) {
      severity = 'error';
      title = 'Performance: High Error Rate';
      description = `Error rate is ${errorRate.toFixed(1)}% over the last ${timeRangeHours} hours`;
      recommendations.push('Investigate connection errors', 'Review error logs', 'Check service status');
    }
    
    if (recommendations.length === 0) {
      recommendations.push('Continue monitoring performance trends');
    }

    return {
      category: 'performance' as const,
      severity,
      title,
      description,
      details: {
        connectionId,
        timeRangeHours,
        metrics: {
          averageResponseTime: Math.round(avgResponseTime),
          errorRate: parseFloat(errorRate.toFixed(1)),
          totalUsage: usageCount,
          trend: avgResponseTime > 1000 ? 'degrading' : 'stable'
        }
      },
      recommendations,
      fixable: severity !== 'info',
      autoFixAction: severity !== 'info' ? 'optimize-performance' : undefined,
      timestamp: new Date().toISOString()
    };

  } catch (error) {
    log?.warn('Performance analysis error', {
      connectionId,
      error: (error as Error).message
    });
    return null;
  }
}

/**
 * Assess connection security
 */
async function assessConnectionSecurity(connection: any): Promise<any> {
  const connectionId = connection.id as number;
  const service = connection.service as string;
  const securityIssues = [];
  const recommendations = [];
  
  // Check for hardcoded credentials (basic check)
  const credentials = connection.credentials || {};
  const credentialKeys = Object.keys(credentials);
  
  for (const key of credentialKeys) {
    const value = credentials[key];
    if (typeof value === 'string' && value.length > 0) {
      // Check for potentially hardcoded secrets
      if (key.toLowerCase().includes('password') && value.length < 12) {
        securityIssues.push('Weak password detected');
      }
      if (key.toLowerCase().includes('secret') && value.startsWith('test_')) {
        securityIssues.push('Test credentials in production');
      }
    }
  }
  
  // Check OAuth scope permissions
  if (credentials.scope) {
    const scopes = (credentials.scope as string).split(' ');
    if (scopes.includes('admin') || scopes.includes('write:all')) {
      securityIssues.push('Excessive permissions detected');
      recommendations.push('Review and limit OAuth scopes to minimum required');
    }
  }
  
  // Check connection age
  if (connection.createdAt) {
    const ageInDays = (Date.now() - new Date(connection.createdAt as string).getTime()) / (1000 * 60 * 60 * 24);
    if (ageInDays > 365) {
      securityIssues.push('Connection is over 1 year old');
      recommendations.push('Consider rotating connection credentials annually');
    }
  }
  
  const securityScore = Math.max(0, 100 - (securityIssues.length * 20));
  
  let severity: 'info' | 'warning' | 'error' | 'critical' = 'info';
  if (securityScore < 40) severity = 'critical';
  else if (securityScore < 60) severity = 'error';
  else if (securityScore < 80) severity = 'warning';
  
  if (recommendations.length === 0) {
    recommendations.push('Maintain current security practices');
  }
  
  return {
    category: 'security' as const,
    severity,
    title: `Security Assessment: ${securityScore >= 80 ? 'Good' : securityScore >= 60 ? 'Fair' : 'Poor'}`,
    description: `Connection security score: ${securityScore}/100`,
    details: {
      connectionId,
      service,
      securityScore,
      issuesFound: securityIssues.length,
      issues: securityIssues
    },
    recommendations,
    fixable: securityIssues.length > 0,
    autoFixAction: securityIssues.length > 0 ? 'apply-security-fixes' : undefined,
    timestamp: new Date().toISOString()
  };
}

/**
 * Check if diagnostic result should be included based on severity filter
 */
function shouldIncludeResult(result: any, severityFilter?: string): boolean {
  if (!severityFilter) return true;
  
  const severityLevels = ['info', 'warning', 'error', 'critical'];
  const resultLevel = severityLevels.indexOf(result.severity);
  const filterLevel = severityLevels.indexOf(severityFilter);
  
  return resultLevel >= filterLevel;
}

/**
 * Calculate connection health score
 */
function calculateConnectionHealthScore(diagnostics: any[]): number {
  let score = 100;
  
  for (const diagnostic of diagnostics) {
    switch (diagnostic.severity) {
      case 'critical':
        score -= 30;
        break;
      case 'error':
        score -= 20;
        break;
      case 'warning':
        score -= 10;
        break;
      case 'info':
        break;
    }
  }
  
  return Math.max(0, score);
}

/**
 * Determine overall connection health
 */
function determineConnectionHealth(diagnostics: any[]): 'healthy' | 'warning' | 'critical' | 'unknown' {
  if (diagnostics.length === 0) return 'unknown';
  
  const hasCritical = diagnostics.some(d => d.severity === 'critical');
  const hasError = diagnostics.some(d => d.severity === 'error');
  const hasWarning = diagnostics.some(d => d.severity === 'warning');
  
  if (hasCritical) return 'critical';
  if (hasError) return 'critical';
  if (hasWarning) return 'warning';
  
  return 'healthy';
}

/**
 * Generate overall diagnostic summary
 */
function generateConnectionDiagnosticSummary(connectionResults: any[]): any {
  const totalConnections = connectionResults.length;
  const healthyConnections = connectionResults.filter(c => c.overallHealth === 'healthy').length;
  const warningConnections = connectionResults.filter(c => c.overallHealth === 'warning').length;
  const criticalConnections = connectionResults.filter(c => c.overallHealth === 'critical').length;
  
  const allDiagnostics = connectionResults.flatMap(c => c.diagnostics);
  const totalIssues = allDiagnostics.length;
  const criticalIssues = allDiagnostics.filter(d => d.severity === 'critical').length;
  const fixableIssues = allDiagnostics.filter(d => d.fixable).length;
  
  const averageHealthScore = connectionResults.reduce((sum, c) => sum + c.healthScore, 0) / totalConnections;
  
  let overallHealth: 'healthy' | 'warning' | 'critical' | 'unknown' = 'healthy';
  if (criticalConnections > 0) overallHealth = 'critical';
  else if (warningConnections > totalConnections * 0.3) overallHealth = 'warning';
  
  return {
    overallHealth,
    healthScore: Math.round(averageHealthScore),
    totalConnections,
    healthyConnections,
    warningConnections,
    criticalConnections,
    totalIssues,
    criticalIssues,
    fixableIssues,
    issuesByCategory: groupIssuesByCategory(allDiagnostics),
    issuesBySeverity: groupIssuesBySeverity(allDiagnostics)
  };
}

/**
 * Generate performance analysis summary
 */
function generatePerformanceAnalysis(connectionResults: any[], timeRangeHours: number): any {
  const performanceDiagnostics = connectionResults
    .flatMap(c => c.diagnostics)
    .filter(d => d.category === 'performance');
    
  if (performanceDiagnostics.length === 0) {
    return {
      summary: 'No performance data available',
      timeRangeHours,
      connectionsAnalyzed: 0
    };
  }
  
  const avgResponseTimes = performanceDiagnostics
    .map(d => d.details?.metrics?.averageResponseTime)
    .filter(t => typeof t === 'number');
    
  const errorRates = performanceDiagnostics
    .map(d => d.details?.metrics?.errorRate)
    .filter(r => typeof r === 'number');
  
  return {
    summary: `Performance analysis for ${performanceDiagnostics.length} connections`,
    timeRangeHours,
    connectionsAnalyzed: performanceDiagnostics.length,
    metrics: {
      averageResponseTime: avgResponseTimes.length > 0 
        ? Math.round(avgResponseTimes.reduce((a, b) => a + b, 0) / avgResponseTimes.length)
        : null,
      averageErrorRate: errorRates.length > 0
        ? parseFloat((errorRates.reduce((a, b) => a + b, 0) / errorRates.length).toFixed(1))
        : null,
      performanceIssues: performanceDiagnostics.filter(d => d.severity !== 'info').length
    }
  };
}

/**
 * Generate security assessment summary
 */
function generateSecurityAssessment(connectionResults: any[]): any {
  const securityDiagnostics = connectionResults
    .flatMap(c => c.diagnostics)
    .filter(d => d.category === 'security');
    
  if (securityDiagnostics.length === 0) {
    return {
      summary: 'No security analysis performed',
      overallSecurityScore: 0,
      connectionsAnalyzed: 0
    };
  }
  
  const securityScores = securityDiagnostics
    .map(d => d.details?.securityScore)
    .filter(s => typeof s === 'number');
    
  const averageSecurityScore = securityScores.length > 0
    ? Math.round(securityScores.reduce((a, b) => a + b, 0) / securityScores.length)
    : 0;
    
  const securityIssues = securityDiagnostics.filter(d => d.severity !== 'info').length;
  
  return {
    summary: `Security assessment for ${securityDiagnostics.length} connections`,
    overallSecurityScore: averageSecurityScore,
    connectionsAnalyzed: securityDiagnostics.length,
    securityIssuesFound: securityIssues,
    recommendations: securityIssues > 0 ? [
      'Review and strengthen connection security',
      'Implement regular security audits',
      'Consider credential rotation policies'
    ] : ['Maintain current security practices']
  };
}

/**
 * Generate actionable recommendations
 */
function generateActionableRecommendations(connectionResults: any[]): any {
  const allRecommendations = connectionResults
    .flatMap(c => c.diagnostics)
    .flatMap(d => d.recommendations);
    
  // Count recommendation frequency
  const recommendationCounts = allRecommendations.reduce((acc, rec) => {
    acc[rec] = (acc[rec] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);
  
  // Get top recommendations
  const topRecommendations = Object.entries(recommendationCounts)
    .sort(([,a], [,b]) => b - a)
    .slice(0, 10)
    .map(([recommendation, count]) => ({ recommendation, count }));
    
  const urgentActions = connectionResults
    .flatMap(c => c.diagnostics)
    .filter(d => d.severity === 'critical')
    .map(d => ({
      connection: connectionResults.find(c => c.diagnostics.includes(d))?.name,
      issue: d.title,
      action: d.recommendations[0]
    }));
    
  return {
    topRecommendations,
    urgentActions,
    summary: `Generated ${topRecommendations.length} unique recommendations based on ${allRecommendations.length} diagnostic findings`
  };
}

/**
 * Group issues by category
 */
function groupIssuesByCategory(diagnostics: any[]): Record<string, number> {
  return diagnostics.reduce((acc, diagnostic) => {
    acc[diagnostic.category] = (acc[diagnostic.category] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);
}

/**
 * Group issues by severity
 */
function groupIssuesBySeverity(diagnostics: any[]): Record<string, number> {
  return diagnostics.reduce((acc, diagnostic) => {
    acc[diagnostic.severity] = (acc[diagnostic.severity] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);
}

export default addConnectionTools;